{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Alfredo/Documents/HERE-MAPS/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../services/here-maps.service\";\nimport * as i2 from \"@angular/common/http\";\nimport * as i3 from \"@angular/common\";\nimport * as i4 from \"@angular/forms\";\nconst _c0 = [\"coverageMap\"];\nfunction CoverageComponent_div_16_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 13);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.successMessage, \" \");\n  }\n}\nfunction CoverageComponent_div_17_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 14);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.errorMessage, \" \");\n  }\n}\nfunction CoverageComponent_div_20_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 17)(1, \"div\", 18)(2, \"div\")(3, \"h4\", 19);\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"p\", 20);\n    i0.ɵɵtext(6);\n    i0.ɵɵpipe(7, \"date\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(8, \"div\")(9, \"button\", 21);\n    i0.ɵɵlistener(\"click\", function CoverageComponent_div_20_div_3_Template_button_click_9_listener() {\n      const polygon_r4 = i0.ɵɵrestoreView(_r3).$implicit;\n      const ctx_r1 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r1.editPolygon(polygon_r4));\n    });\n    i0.ɵɵtext(10, \" Editar \");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(11, \"button\", 22);\n    i0.ɵɵlistener(\"click\", function CoverageComponent_div_20_div_3_Template_button_click_11_listener() {\n      const polygon_r4 = i0.ɵɵrestoreView(_r3).$implicit;\n      const ctx_r1 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r1.togglePolygonVisibility(polygon_r4));\n    });\n    i0.ɵɵtext(12);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(13, \"button\", 23);\n    i0.ɵɵlistener(\"click\", function CoverageComponent_div_20_div_3_Template_button_click_13_listener() {\n      const polygon_r4 = i0.ɵɵrestoreView(_r3).$implicit;\n      const ctx_r1 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r1.deletePolygon(polygon_r4.id));\n    });\n    i0.ɵɵtext(14, \" Eliminar \");\n    i0.ɵɵelementEnd()()()();\n  }\n  if (rf & 2) {\n    const polygon_r4 = ctx.$implicit;\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate(polygon_r4.name);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate2(\" \", polygon_r4.coordinates.length, \" puntos | Creado: \", i0.ɵɵpipeBind2(7, 4, polygon_r4.created, \"short\"), \" \");\n    i0.ɵɵadvance(6);\n    i0.ɵɵtextInterpolate1(\" \", polygon_r4.visible ? \"Ocultar\" : \"Mostrar\", \" \");\n  }\n}\nfunction CoverageComponent_div_20_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 15)(1, \"h3\");\n    i0.ɵɵtext(2, \"\\u00C1reas de Cobertura Guardadas\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, CoverageComponent_div_20_div_3_Template, 15, 7, \"div\", 16);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.savedPolygons);\n  }\n}\nexport let CoverageComponent = /*#__PURE__*/(() => {\n  class CoverageComponent {\n    constructor(hereMapsService, http) {\n      this.hereMapsService = hereMapsService;\n      this.http = http;\n      this.currentPolygonName = '';\n      this.isDrawing = false;\n      this.currentPoints = [];\n      this.savedPolygons = [];\n      this.successMessage = '';\n      this.errorMessage = '';\n      this.currentMarkers = [];\n      this.currentPolygon = null;\n      this.editingPolygon = null;\n    }\n    ngOnInit() {\n      this.initializeMap();\n      setTimeout(() => {\n        this.loadSavedPolygons();\n      }, 1000);\n    }\n    ngOnDestroy() {\n      this.clearCurrentDrawing();\n    }\n    initializeMap() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        if (!_this.mapContainer?.nativeElement) {\n          setTimeout(() => _this.initializeMap(), 1000);\n          return;\n        }\n        const defaultCenter = {\n          lat: 19.4326,\n          lng: -99.1332\n        };\n        try {\n          const mapInstance = yield _this.hereMapsService.createMap(_this.mapContainer.nativeElement, defaultCenter, 12);\n          _this.map = mapInstance.map;\n          _this.ui = mapInstance.ui;\n          _this.behavior = mapInstance.behavior;\n          _this.setupMapEvents();\n          _this.clearMessages();\n        } catch (error) {\n          _this.errorMessage = `Error al inicializar el mapa: ${error instanceof Error ? error.message : 'Error desconocido'}`;\n        }\n      })();\n    }\n    setupMapEvents() {\n      if (!this.map) return;\n      this.map.addEventListener('tap', evt => {\n        if (!this.isDrawing) return;\n        try {\n          const coord = this.map.screenToGeo(evt.currentPointer.viewportX, evt.currentPointer.viewportY);\n          if (coord && coord.hasOwnProperty('lat') && coord.hasOwnProperty('lng') && typeof coord.lat === 'number' && typeof coord.lng === 'number' && !isNaN(coord.lat) && !isNaN(coord.lng)) {\n            this.addPointToCurrentPolygon(coord.lat, coord.lng);\n          } else {\n            console.error('Coordenadas inválidas del mapa:', coord);\n            this.errorMessage = 'Error: coordenadas inválidas obtenidas del mapa';\n          }\n        } catch (error) {\n          console.error('Error obteniendo coordenadas del mapa:', error);\n        }\n      });\n      this.map.addEventListener('dbltap', evt => {\n        if (!this.isDrawing || this.currentPoints.length < 3) return;\n        evt.stopPropagation();\n        this.completeCurrentPolygon();\n      });\n    }\n    startDrawing() {\n      if (!this.currentPolygonName.trim()) {\n        this.errorMessage = 'Ingresa un nombre para el área de cobertura';\n        return;\n      }\n      this.isDrawing = true;\n      this.currentPoints = [];\n      this.clearCurrentDrawing();\n      this.clearMessages();\n    }\n    cancelDrawing() {\n      this.isDrawing = false;\n      this.clearCurrentDrawing();\n      this.editingPolygon = null;\n    }\n    addPointToCurrentPolygon(lat, lng) {\n      if (typeof lat !== 'number' || typeof lng !== 'number' || isNaN(lat) || isNaN(lng)) {\n        console.error('Coordenadas inválidas:', {\n          lat,\n          lng\n        });\n        this.errorMessage = 'Error: coordenadas inválidas para agregar punto';\n        return;\n      }\n      // Validación adicional de rangos\n      if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {\n        console.error('Coordenadas fuera de rango:', {\n          lat,\n          lng\n        });\n        this.errorMessage = 'Error: coordenadas fuera del rango válido';\n        return;\n      }\n      const point = {\n        lat: Number(lat),\n        lng: Number(lng)\n      };\n      this.currentPoints.push(point);\n      try {\n        const marker = this.hereMapsService.addMarker(this.map, point, {\n          icon: new H.map.Icon(`<svg width=\"24\" height=\"24\" xmlns=\"http://www.w3.org/2000/svg\">\n            <circle cx=\"12\" cy=\"12\" r=\"8\" fill=\"red\" stroke=\"white\" stroke-width=\"3\"/>\n            <text x=\"12\" y=\"17\" text-anchor=\"middle\" fill=\"white\" font-size=\"10\" font-weight=\"bold\">${this.currentPoints.length}</text>\n          </svg>`, {\n            size: {\n              w: 24,\n              h: 24\n            }\n          })\n        });\n        this.currentMarkers.push(marker);\n        this.updateCurrentPolygonDisplay();\n        this.clearMessages(); // Limpiar mensajes de error anteriores\n      } catch (error) {\n        console.error('Error creando marcador:', error);\n        this.errorMessage = 'Error agregando marcador al mapa';\n        this.currentPoints.pop(); // Remover el punto si falló agregar el marcador\n      }\n    }\n    updateCurrentPolygonDisplay() {\n      if (this.currentPoints.length < 2) return;\n      if (this.currentPolygon) {\n        this.map.removeObject(this.currentPolygon);\n      }\n      if (this.currentPoints.length >= 3) {\n        try {\n          console.log('Intentando crear polígono con método directo');\n          this.currentPolygon = this.createPolygonDirect(this.currentPoints);\n          // Aplicar estilos\n          this.currentPolygon.setStyle({\n            strokeColor: 'rgba(255, 0, 0, 0.8)',\n            fillColor: 'rgba(255, 0, 0, 0.3)',\n            lineWidth: 3\n          });\n          this.map.addObject(this.currentPolygon);\n          console.log('Polígono creado exitosamente con método directo');\n        } catch (error) {\n          console.error('Error con método directo, intentando método LineString:', error);\n          try {\n            console.log('Usando método safeCreateLineString como fallback');\n            const lineString = this.safeCreateLineString(this.currentPoints);\n            this.currentPolygon = new H.map.Polygon(lineString, {\n              style: {\n                strokeColor: 'rgba(255, 0, 0, 0.8)',\n                fillColor: 'rgba(255, 0, 0, 0.3)',\n                lineWidth: 3\n              }\n            });\n            this.map.addObject(this.currentPolygon);\n            console.log('Método LineString exitoso como fallback');\n          } catch (fallbackError) {\n            console.error('Error con todos los métodos:', fallbackError);\n            this.errorMessage = `Error al mostrar polígono: ${error instanceof Error ? error.message : 'Error desconocido'}`;\n          }\n        }\n      }\n    }\n    completeCurrentPolygon() {\n      if (this.currentPoints.length < 3) {\n        this.errorMessage = 'Se necesitan al menos 3 puntos para crear un polígono';\n        return;\n      }\n      this.updateCurrentPolygonDisplay();\n    }\n    canSavePolygon() {\n      return this.currentPoints.length >= 3 && this.currentPolygonName.trim() !== '';\n    }\n    saveCurrentPolygon() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        if (!_this2.canSavePolygon()) {\n          _this2.errorMessage = 'Se necesitan al menos 3 puntos y un nombre para guardar el polígono';\n          return;\n        }\n        const polygon = {\n          id: _this2.editingPolygon ? _this2.editingPolygon.id : _this2.generateId(),\n          name: _this2.currentPolygonName.trim(),\n          coordinates: [..._this2.currentPoints],\n          created: _this2.editingPolygon ? _this2.editingPolygon.created : new Date(),\n          updated: new Date()\n        };\n        try {\n          if (_this2.editingPolygon) {\n            yield _this2.updatePolygon(polygon);\n            _this2.successMessage = `Área \"${polygon.name}\" actualizada correctamente`;\n          } else {\n            yield _this2.createPolygon(polygon);\n            _this2.successMessage = `Área \"${polygon.name}\" guardada correctamente`;\n          }\n          _this2.resetDrawing();\n          _this2.loadSavedPolygons();\n          _this2.clearMessagesAfterDelay();\n        } catch (error) {\n          _this2.errorMessage = `Error al guardar el área: ${error instanceof Error ? error.message : 'Error desconocido'}`;\n        }\n      })();\n    }\n    createPolygon(polygon) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        return new Promise((resolve, reject) => {\n          _this3.http.post('http://localhost:3000/api/coverage', polygon).subscribe({\n            next: () => resolve(),\n            error: error => reject(error?.message || 'Error del servidor')\n          });\n        });\n      })();\n    }\n    updatePolygon(polygon) {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        return new Promise((resolve, reject) => {\n          _this4.http.post(`http://localhost:3000/api/coverage/${polygon.id}`, polygon).subscribe({\n            next: () => resolve(),\n            error: error => reject(error?.message || 'Error del servidor')\n          });\n        });\n      })();\n    }\n    loadSavedPolygons() {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          _this5.http.get('http://localhost:3000/api/coverage').subscribe({\n            next: polygons => {\n              _this5.savedPolygons = polygons.map(p => ({\n                ...p,\n                visible: true\n              }));\n              _this5.displaySavedPolygons();\n              _this5.clearMessages();\n            },\n            error: error => {\n              if (error.status === 0) {\n                _this5.errorMessage = 'No se puede conectar con el servidor. Asegúrate de que el backend esté ejecutándose en http://localhost:3000';\n                setTimeout(() => {\n                  _this5.loadSavedPolygons();\n                }, 5000);\n              } else {\n                _this5.errorMessage = `Error cargando áreas de cobertura: ${error?.message || error?.statusText || 'Error desconocido'}`;\n              }\n              console.error('Error cargando polígonos:', error);\n            }\n          });\n        } catch (error) {\n          _this5.errorMessage = 'Error inesperado al cargar las áreas de cobertura.';\n          console.error('Error al cargar polígonos guardados:', error);\n        }\n      })();\n    }\n    displaySavedPolygons() {\n      if (!this.map) return;\n      this.savedPolygons.forEach(polygon => {\n        if (polygon.coordinates.length >= 3) {\n          this.createPolygonOnMap(polygon);\n        }\n      });\n    }\n    createPolygonOnMap(polygon) {\n      if (polygon.mapPolygon) {\n        this.map.removeObject(polygon.mapPolygon);\n      }\n      try {\n        console.log(`Creando polígono guardado para ${polygon.name} con método directo`);\n        polygon.mapPolygon = this.createPolygonDirect(polygon.coordinates);\n        const color = this.getRandomColor();\n        polygon.mapPolygon.setStyle({\n          strokeColor: `rgba(${color.r}, ${color.g}, ${color.b}, 0.8)`,\n          fillColor: `rgba(${color.r}, ${color.g}, ${color.b}, 0.3)`,\n          lineWidth: 2\n        });\n        if (polygon.visible !== false) {\n          this.map.addObject(polygon.mapPolygon);\n        }\n        console.log(`Polígono ${polygon.name} creado exitosamente con método directo`);\n      } catch (error) {\n        console.error(`Error con método directo para ${polygon.name}, intentando LineString:`, error);\n        try {\n          console.log(`Usando método LineString para polígono ${polygon.name}`);\n          const lineString = this.safeCreateLineString(polygon.coordinates);\n          const color = this.getRandomColor();\n          polygon.mapPolygon = new H.map.Polygon(lineString, {\n            style: {\n              strokeColor: `rgba(${color.r}, ${color.g}, ${color.b}, 0.8)`,\n              fillColor: `rgba(${color.r}, ${color.g}, ${color.b}, 0.3)`,\n              lineWidth: 2\n            }\n          });\n          if (polygon.visible !== false) {\n            this.map.addObject(polygon.mapPolygon);\n          }\n          console.log(`Método LineString exitoso para ${polygon.name}`);\n        } catch (fallbackError) {\n          console.error(`Error con todos los métodos para ${polygon.name}:`, fallbackError);\n        }\n      }\n    }\n    editPolygon(polygon) {\n      this.editingPolygon = polygon;\n      this.currentPolygonName = polygon.name;\n      this.currentPoints = [...polygon.coordinates];\n      this.isDrawing = true;\n      this.clearCurrentDrawing();\n      this.currentPoints.forEach((point, index) => {\n        const marker = this.hereMapsService.addMarker(this.map, point, {\n          icon: new H.map.Icon(`<svg width=\"24\" height=\"24\" xmlns=\"http://www.w3.org/2000/svg\">\n            <circle cx=\"12\" cy=\"12\" r=\"8\" fill=\"blue\" stroke=\"white\" stroke-width=\"3\"/>\n            <text x=\"12\" y=\"17\" text-anchor=\"middle\" fill=\"white\" font-size=\"10\" font-weight=\"bold\">${index + 1}</text>\n          </svg>`, {\n            size: {\n              w: 24,\n              h: 24\n            }\n          })\n        });\n        this.currentMarkers.push(marker);\n      });\n      this.updateCurrentPolygonDisplay();\n      this.map.setCenter(polygon.coordinates[0]);\n      this.clearMessages();\n    }\n    togglePolygonVisibility(polygon) {\n      polygon.visible = !polygon.visible;\n      if (polygon.visible) {\n        if (polygon.mapPolygon) {\n          this.map.addObject(polygon.mapPolygon);\n        }\n      } else {\n        if (polygon.mapPolygon) {\n          this.map.removeObject(polygon.mapPolygon);\n        }\n      }\n    }\n    deletePolygon(polygonId) {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        if (!confirm('¿Estás seguro de que quieres eliminar esta área de cobertura?')) {\n          return;\n        }\n        try {\n          yield new Promise((resolve, reject) => {\n            _this6.http.post(`http://localhost:3000/api/coverage/delete/${polygonId}`, {}).subscribe({\n              next: () => resolve(null),\n              error: error => reject(error)\n            });\n          });\n          const polygonIndex = _this6.savedPolygons.findIndex(p => p.id === polygonId);\n          if (polygonIndex !== -1) {\n            const polygon = _this6.savedPolygons[polygonIndex];\n            if (polygon.mapPolygon) {\n              _this6.map.removeObject(polygon.mapPolygon);\n            }\n            _this6.savedPolygons.splice(polygonIndex, 1);\n          }\n          _this6.successMessage = 'Área eliminada correctamente';\n          _this6.clearMessagesAfterDelay();\n        } catch (error) {\n          _this6.errorMessage = `Error al eliminar el área: ${error instanceof Error ? error.message : 'Error desconocido'}`;\n        }\n      })();\n    }\n    resetDrawing() {\n      this.isDrawing = false;\n      this.currentPolygonName = '';\n      this.currentPoints = [];\n      this.editingPolygon = null;\n      this.clearCurrentDrawing();\n    }\n    clearCurrentDrawing() {\n      if (!this.map) return;\n      this.currentMarkers.forEach(marker => {\n        this.map.removeObject(marker);\n      });\n      this.currentMarkers = [];\n      if (this.currentPolygon) {\n        this.map.removeObject(this.currentPolygon);\n        this.currentPolygon = null;\n      }\n    }\n    generateId() {\n      return Date.now().toString(36) + Math.random().toString(36).substr(2);\n    }\n    getRandomColor() {\n      return {\n        r: Math.floor(Math.random() * 128) + 128,\n        g: Math.floor(Math.random() * 128) + 64,\n        b: Math.floor(Math.random() * 128) + 128\n      };\n    }\n    clearMessages() {\n      this.successMessage = '';\n      this.errorMessage = '';\n    }\n    clearMessagesAfterDelay() {\n      setTimeout(() => {\n        this.clearMessages();\n      }, 3000);\n    }\n    validateAndCleanPoints(points) {\n      const cleaned = points.filter(point => {\n        if (!point) {\n          console.warn('Punto nulo o undefined filtrado:', point);\n          return false;\n        }\n        if (typeof point.lat !== 'number' || typeof point.lng !== 'number') {\n          console.warn('Punto con tipos incorrectos filtrado:', point, typeof point.lat, typeof point.lng);\n          return false;\n        }\n        if (isNaN(point.lat) || isNaN(point.lng)) {\n          console.warn('Punto con NaN filtrado:', point);\n          return false;\n        }\n        if (point.lat < -90 || point.lat > 90 || point.lng < -180 || point.lng > 180) {\n          console.warn('Punto fuera de rango filtrado:', point);\n          return false;\n        }\n        return true;\n      });\n      if (cleaned.length !== points.length) {\n        console.log(`validateAndCleanPoints: ${points.length - cleaned.length} puntos filtrados de ${points.length}`);\n      }\n      return cleaned;\n    }\n    safeCreateLineString(points) {\n      console.log('safeCreateLineString - puntos recibidos:', points);\n      const validPoints = this.validateAndCleanPoints(points);\n      console.log('safeCreateLineString - puntos válidos:', validPoints);\n      if (validPoints.length < 3) {\n        throw new Error(`Insuficientes puntos válidos: ${validPoints.length}. Se necesitan al menos 3.`);\n      }\n      const lineString = new H.geo.LineString();\n      validPoints.forEach((point, index) => {\n        console.log(`Agregando punto ${index}:`, point);\n        // Extraer coordenadas a variables locales\n        const lat = Number(point.lat);\n        const lng = Number(point.lng);\n        console.log(`Coordenadas extraídas ${index}: lat=${lat} (${typeof lat}), lng=${lng} (${typeof lng})`);\n        if (typeof lat !== 'number' || typeof lng !== 'number' || isNaN(lat) || isNaN(lng)) {\n          console.error('Coordenadas extraídas inválidas:', {\n            lat,\n            lng\n          });\n          return;\n        }\n        try {\n          console.log(`Llamando pushPoint(${lat}, ${lng})`);\n          lineString.pushPoint(lat, lng);\n          console.log(`pushPoint exitoso para punto ${index}`);\n        } catch (error) {\n          console.error(`Error en pushPoint con punto ${index}:`, {\n            lat,\n            lng\n          }, error);\n          throw error;\n        }\n      });\n      const firstPoint = validPoints[0];\n      console.log('Cerrando polígono con primer punto:', firstPoint);\n      // Extraer coordenadas del primer punto\n      const firstLat = Number(firstPoint.lat);\n      const firstLng = Number(firstPoint.lng);\n      console.log(`Coordenadas primer punto: lat=${firstLat} (${typeof firstLat}), lng=${firstLng} (${typeof firstLng})`);\n      if (typeof firstLat !== 'number' || typeof firstLng !== 'number' || isNaN(firstLat) || isNaN(firstLng)) {\n        console.error('Coordenadas primer punto inválidas:', {\n          firstLat,\n          firstLng\n        });\n        throw new Error('Primer punto inválido para cerrar polígono');\n      }\n      try {\n        console.log(`Cerrando polígono con pushPoint(${firstLat}, ${firstLng})`);\n        lineString.pushPoint(firstLat, firstLng);\n        console.log('Polígono cerrado exitosamente');\n      } catch (error) {\n        console.error('Error cerrando polígono:', {\n          firstLat,\n          firstLng\n        }, error);\n        throw error;\n      }\n      return lineString;\n    }\n    // Método alternativo usando constructor directo de Polygon\n    createPolygonDirect(points) {\n      console.log('createPolygonDirect - iniciando con puntos:', points);\n      // Filtrar y limpiar puntos\n      const safePoints = points.filter(p => p && typeof p.lat === 'number' && typeof p.lng === 'number').filter(p => !isNaN(p.lat) && !isNaN(p.lng)).filter(p => p.lat >= -90 && p.lat <= 90 && p.lng >= -180 && p.lng <= 180);\n      console.log('createPolygonDirect - puntos seguros:', safePoints);\n      if (safePoints.length < 3) {\n        throw new Error(`Método directo: Insuficientes puntos válidos: ${safePoints.length}`);\n      }\n      // Crear array de coordenadas en el formato que HERE Maps espera\n      const coordinates = [];\n      safePoints.forEach(point => {\n        coordinates.push([point.lat, point.lng]);\n      });\n      // Cerrar el polígono agregando el primer punto al final\n      coordinates.push([safePoints[0].lat, safePoints[0].lng]);\n      console.log('createPolygonDirect - coordenadas para HERE Maps:', coordinates);\n      try {\n        // Método 1: Crear usando LinearRing (más directo y confiable)\n        console.log('Intentando método LinearRing');\n        const ring = new H.geo.LinearRing();\n        for (const point of safePoints) {\n          const lat = Number(point.lat);\n          const lng = Number(point.lng);\n          console.log(`Ring: agregando (${lat}, ${lng})`);\n          ring.pushPoint(lat, lng);\n        }\n        const polygon = new H.map.Polygon(new H.geo.Polygon(ring));\n        console.log('Polígono creado exitosamente con LinearRing');\n        return polygon;\n      } catch (error) {\n        console.error('Error con LinearRing, intentando método Strip:', error);\n        try {\n          // Método 2: Usar LineString Strip\n          console.log('Intentando método LineString Strip');\n          const strip = new H.geo.Strip();\n          for (const point of safePoints) {\n            const lat = Number(point.lat);\n            const lng = Number(point.lng);\n            console.log(`Strip: agregando (${lat}, ${lng})`);\n            strip.pushPoint(lat, lng);\n          }\n          // Cerrar el strip agregando el primer punto\n          strip.pushPoint(safePoints[0].lat, safePoints[0].lng);\n          const polygon = new H.map.Polygon(strip, {\n            style: {\n              strokeColor: 'rgba(255, 0, 0, 0.8)',\n              fillColor: 'rgba(255, 0, 0, 0.3)',\n              lineWidth: 3\n            }\n          });\n          console.log('Polígono creado exitosamente con Strip');\n          return polygon;\n        } catch (stripError) {\n          console.error('Error también con Strip, lanzando error:', stripError);\n          throw new Error(`Todos los métodos fallaron: ${error.message}`);\n        }\n      }\n    }\n    static {\n      this.ɵfac = function CoverageComponent_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || CoverageComponent)(i0.ɵɵdirectiveInject(i1.HereMapsService), i0.ɵɵdirectiveInject(i2.HttpClient));\n      };\n    }\n    static {\n      this.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n        type: CoverageComponent,\n        selectors: [[\"app-coverage\"]],\n        viewQuery: function CoverageComponent_Query(rf, ctx) {\n          if (rf & 1) {\n            i0.ɵɵviewQuery(_c0, 7);\n          }\n          if (rf & 2) {\n            let _t;\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.mapContainer = _t.first);\n          }\n        },\n        standalone: true,\n        features: [i0.ɵɵStandaloneFeature],\n        decls: 21,\n        vars: 9,\n        consts: [[\"coverageMap\", \"\"], [1, \"card\"], [1, \"alert\", \"alert-info\"], [1, \"form-group\"], [\"for\", \"polygonName\"], [\"id\", \"polygonName\", \"type\", \"text\", \"placeholder\", \"Ingresa el nombre del \\u00E1rea\", 1, \"form-control\", 3, \"ngModelChange\", \"ngModel\", \"disabled\"], [1, \"btn\", \"btn-primary\", 3, \"click\", \"disabled\"], [1, \"btn\", \"btn-secondary\", 2, \"margin-left\", \"10px\", 3, \"click\", \"disabled\"], [1, \"btn\", \"btn-success\", 2, \"margin-left\", \"10px\", 3, \"click\", \"disabled\"], [\"class\", \"alert alert-success\", 4, \"ngIf\"], [\"class\", \"alert alert-error\", 4, \"ngIf\"], [1, \"map-container\", 2, \"height\", \"500px\", \"border\", \"2px solid #ddd\"], [\"class\", \"card\", \"style\", \"margin-top: 20px;\", 4, \"ngIf\"], [1, \"alert\", \"alert-success\"], [1, \"alert\", \"alert-error\"], [1, \"card\", 2, \"margin-top\", \"20px\"], [\"class\", \"polygon-item\", \"style\", \"padding: 15px; border: 1px solid #ddd; margin: 10px 0; border-radius: 4px; background-color: #f8f9fa;\", 4, \"ngFor\", \"ngForOf\"], [1, \"polygon-item\", 2, \"padding\", \"15px\", \"border\", \"1px solid #ddd\", \"margin\", \"10px 0\", \"border-radius\", \"4px\", \"background-color\", \"#f8f9fa\"], [2, \"display\", \"flex\", \"justify-content\", \"space-between\", \"align-items\", \"center\"], [2, \"margin\", \"0\", \"color\", \"#333\"], [2, \"margin\", \"5px 0\", \"font-size\", \"14px\", \"color\", \"#666\"], [1, \"btn\", \"btn-info\", 2, \"margin-right\", \"10px\", \"font-size\", \"12px\", 3, \"click\"], [1, \"btn\", \"btn-warning\", 2, \"margin-right\", \"10px\", \"font-size\", \"12px\", 3, \"click\"], [1, \"btn\", \"btn-danger\", 2, \"font-size\", \"12px\", 3, \"click\"]],\n        template: function CoverageComponent_Template(rf, ctx) {\n          if (rf & 1) {\n            const _r1 = i0.ɵɵgetCurrentView();\n            i0.ɵɵelementStart(0, \"div\", 1)(1, \"h2\");\n            i0.ɵɵtext(2, \"Gesti\\u00F3n de Cobertura\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(3, \"div\", 2);\n            i0.ɵɵtext(4, \" Haz clic en el mapa para crear puntos del pol\\u00EDgono. Haz doble clic para completar el pol\\u00EDgono. \");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(5, \"div\", 3)(6, \"label\", 4);\n            i0.ɵɵtext(7, \"Nombre del \\u00E1rea de cobertura:\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(8, \"input\", 5);\n            i0.ɵɵtwoWayListener(\"ngModelChange\", function CoverageComponent_Template_input_ngModelChange_8_listener($event) {\n              i0.ɵɵrestoreView(_r1);\n              i0.ɵɵtwoWayBindingSet(ctx.currentPolygonName, $event) || (ctx.currentPolygonName = $event);\n              return i0.ɵɵresetView($event);\n            });\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(9, \"div\", 3)(10, \"button\", 6);\n            i0.ɵɵlistener(\"click\", function CoverageComponent_Template_button_click_10_listener() {\n              i0.ɵɵrestoreView(_r1);\n              return i0.ɵɵresetView(ctx.startDrawing());\n            });\n            i0.ɵɵtext(11, \" Crear Nueva \\u00C1rea \");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(12, \"button\", 7);\n            i0.ɵɵlistener(\"click\", function CoverageComponent_Template_button_click_12_listener() {\n              i0.ɵɵrestoreView(_r1);\n              return i0.ɵɵresetView(ctx.cancelDrawing());\n            });\n            i0.ɵɵtext(13, \" Cancelar \");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(14, \"button\", 8);\n            i0.ɵɵlistener(\"click\", function CoverageComponent_Template_button_click_14_listener() {\n              i0.ɵɵrestoreView(_r1);\n              return i0.ɵɵresetView(ctx.saveCurrentPolygon());\n            });\n            i0.ɵɵtext(15);\n            i0.ɵɵelementEnd()();\n            i0.ɵɵtemplate(16, CoverageComponent_div_16_Template, 2, 1, \"div\", 9)(17, CoverageComponent_div_17_Template, 2, 1, \"div\", 10);\n            i0.ɵɵelement(18, \"div\", 11, 0);\n            i0.ɵɵtemplate(20, CoverageComponent_div_20_Template, 4, 1, \"div\", 12);\n            i0.ɵɵelementEnd();\n          }\n          if (rf & 2) {\n            i0.ɵɵadvance(8);\n            i0.ɵɵtwoWayProperty(\"ngModel\", ctx.currentPolygonName);\n            i0.ɵɵproperty(\"disabled\", ctx.isDrawing);\n            i0.ɵɵadvance(2);\n            i0.ɵɵproperty(\"disabled\", ctx.isDrawing || !ctx.currentPolygonName.trim());\n            i0.ɵɵadvance(2);\n            i0.ɵɵproperty(\"disabled\", !ctx.isDrawing);\n            i0.ɵɵadvance(2);\n            i0.ɵɵproperty(\"disabled\", !ctx.canSavePolygon());\n            i0.ɵɵadvance();\n            i0.ɵɵtextInterpolate1(\" Guardar \\u00C1rea (\", ctx.currentPoints.length, \" puntos) \");\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.successMessage);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.errorMessage);\n            i0.ɵɵadvance(3);\n            i0.ɵɵproperty(\"ngIf\", ctx.savedPolygons.length > 0);\n          }\n        },\n        dependencies: [CommonModule, i3.NgForOf, i3.NgIf, i3.DatePipe, FormsModule, i4.DefaultValueAccessor, i4.NgControlStatus, i4.NgModel],\n        styles: [\".polygon-item[_ngcontent-%COMP%]:hover{background-color:#e9ecef!important}.alert-error[_ngcontent-%COMP%]{color:#721c24;background-color:#f8d7da;border-color:#f5c6cb;padding:.75rem 1.25rem;margin-bottom:1rem;border:1px solid;border-radius:.25rem}.alert-success[_ngcontent-%COMP%]{color:#155724;background-color:#d4edda;border-color:#c3e6cb;padding:.75rem 1.25rem;margin-bottom:1rem;border:1px solid;border-radius:.25rem}.alert-info[_ngcontent-%COMP%]{color:#0c5460;background-color:#d1ecf1;border-color:#bee5eb;padding:.75rem 1.25rem;margin-bottom:1rem;border:1px solid;border-radius:.25rem}\"]\n      });\n    }\n  }\n  return CoverageComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}