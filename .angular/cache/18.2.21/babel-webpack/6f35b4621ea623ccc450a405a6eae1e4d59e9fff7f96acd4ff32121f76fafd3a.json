{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Alfredo/Documents/HERE-MAPS/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { AddressSearchComponent } from '../address-search/address-search.component';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../services/here-maps.service\";\nimport * as i2 from \"@angular/common/http\";\nimport * as i3 from \"../../services/polygon-analysis.service\";\nimport * as i4 from \"@angular/common\";\nimport * as i5 from \"@angular/forms\";\nconst _c0 = [\"coverageMap\"];\nfunction CoverageComponent_div_16_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 16);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.successMessage, \" \");\n  }\n}\nfunction CoverageComponent_div_17_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 17);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.errorMessage, \" \");\n  }\n}\nfunction CoverageComponent_div_18_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 2);\n    i0.ɵɵtext(1, \" \\uD83D\\uDCDD Modo de edici\\u00F3n activo: \");\n    i0.ɵɵelement(2, \"br\");\n    i0.ɵɵtext(3, \"\\u2022 \");\n    i0.ɵɵelementStart(4, \"strong\");\n    i0.ɵɵtext(5, \"Haz clic en el mapa\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵtext(6, \" para agregar nuevos puntos \");\n    i0.ɵɵelement(7, \"br\");\n    i0.ɵɵtext(8, \"\\u2022 \");\n    i0.ɵɵelementStart(9, \"strong\");\n    i0.ɵɵtext(10, \"Arrastra los c\\u00EDrculos rojos\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵtext(11, \" para mover puntos existentes \");\n    i0.ɵɵelement(12, \"br\");\n    i0.ɵɵtext(13, \"\\u2022 \");\n    i0.ɵɵelementStart(14, \"strong\");\n    i0.ɵɵtext(15, \"Doble clic en un c\\u00EDrculo rojo\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵtext(16, \" para eliminar ese punto (m\\u00EDn. 3 puntos) \");\n    i0.ɵɵelementEnd();\n  }\n}\nfunction CoverageComponent_div_21_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtext(1, \" \\u2705 \");\n    i0.ɵɵelementStart(2, \"strong\");\n    i0.ɵɵtext(3, \"Dentro del pol\\u00EDgono:\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.mapClickAnalysis.result.name, \" \");\n  }\n}\nfunction CoverageComponent_div_21_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtext(1, \" \\uD83D\\uDCCD \");\n    i0.ɵɵelementStart(2, \"strong\");\n    i0.ɵɵtext(3, \"Pol\\u00EDgono m\\u00E1s cercano:\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate2(\" \", ctx_r1.mapClickAnalysis.result.name, \" (\", ctx_r1.mapClickAnalysis.distance, \" km) \");\n  }\n}\nfunction CoverageComponent_div_21_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtext(1, \" \\u274C \");\n    i0.ɵɵelementStart(2, \"strong\");\n    i0.ɵɵtext(3, \"No hay pol\\u00EDgonos definidos\");\n    i0.ɵɵelementEnd()();\n  }\n}\nfunction CoverageComponent_div_21_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 18)(1, \"h4\");\n    i0.ɵɵtext(2, \"Informaci\\u00F3n del Punto Seleccionado:\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, CoverageComponent_div_21_div_3_Template, 5, 1, \"div\", 19)(4, CoverageComponent_div_21_div_4_Template, 5, 2, \"div\", 19)(5, CoverageComponent_div_21_div_5_Template, 4, 0, \"div\", 19);\n    i0.ɵɵelementStart(6, \"div\", 20);\n    i0.ɵɵtext(7);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(8, \"button\", 21);\n    i0.ɵɵlistener(\"click\", function CoverageComponent_div_21_Template_button_click_8_listener() {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.clearMapClickAnalysis());\n    });\n    i0.ɵɵtext(9, \" Limpiar \");\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.mapClickAnalysis.status === \"inside\");\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.mapClickAnalysis.status === \"outside\");\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.mapClickAnalysis.status === \"no_polygons\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate2(\" Coordenadas: \", ctx_r1.mapClickAnalysis.coordinates.lat.toFixed(6), \", \", ctx_r1.mapClickAnalysis.coordinates.lng.toFixed(6), \" \");\n  }\n}\nfunction CoverageComponent_div_23_div_3_span_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 33);\n    i0.ɵɵtext(1, \" | \\u270F\\uFE0F Modo Edici\\u00F3n\");\n    i0.ɵɵelementEnd();\n  }\n}\nfunction CoverageComponent_div_23_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 24)(1, \"div\", 25)(2, \"div\")(3, \"h4\", 26);\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"p\", 27);\n    i0.ɵɵtext(6);\n    i0.ɵɵpipe(7, \"date\");\n    i0.ɵɵtemplate(8, CoverageComponent_div_23_div_3_span_8_Template, 2, 0, \"span\", 28);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(9, \"div\")(10, \"button\", 29);\n    i0.ɵɵlistener(\"click\", function CoverageComponent_div_23_div_3_Template_button_click_10_listener() {\n      const polygon_r5 = i0.ɵɵrestoreView(_r4).$implicit;\n      const ctx_r1 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r1.editPolygonProperties(polygon_r5));\n    });\n    i0.ɵɵtext(11, \" Editar Nombre \");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(12, \"button\", 30);\n    i0.ɵɵlistener(\"click\", function CoverageComponent_div_23_div_3_Template_button_click_12_listener() {\n      const polygon_r5 = i0.ɵɵrestoreView(_r4).$implicit;\n      const ctx_r1 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r1.toggleEditableMode(polygon_r5));\n    });\n    i0.ɵɵtext(13);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(14, \"button\", 31);\n    i0.ɵɵlistener(\"click\", function CoverageComponent_div_23_div_3_Template_button_click_14_listener() {\n      const polygon_r5 = i0.ɵɵrestoreView(_r4).$implicit;\n      const ctx_r1 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r1.togglePolygonVisibility(polygon_r5));\n    });\n    i0.ɵɵtext(15);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(16, \"button\", 32);\n    i0.ɵɵlistener(\"click\", function CoverageComponent_div_23_div_3_Template_button_click_16_listener() {\n      const polygon_r5 = i0.ɵɵrestoreView(_r4).$implicit;\n      const ctx_r1 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r1.deletePolygon(polygon_r5.id));\n    });\n    i0.ɵɵtext(17, \" Eliminar \");\n    i0.ɵɵelementEnd()()()();\n  }\n  if (rf & 2) {\n    const polygon_r5 = ctx.$implicit;\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate(polygon_r5.name);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate2(\" \", polygon_r5.coordinates.length, \" puntos | Creado: \", i0.ɵɵpipeBind2(7, 10, polygon_r5.created, \"short\"), \" \");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", polygon_r5.editable);\n    i0.ɵɵadvance(4);\n    i0.ɵɵclassProp(\"btn-success\", polygon_r5.editable)(\"btn-secondary\", !polygon_r5.editable);\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", polygon_r5.editable ? \"Finalizar Edici\\u00F3n\" : \"Editar Forma\", \" \");\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", polygon_r5.visible ? \"Ocultar\" : \"Mostrar\", \" \");\n  }\n}\nfunction CoverageComponent_div_23_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 22)(1, \"h3\");\n    i0.ɵɵtext(2, \"\\u00C1reas de Cobertura Guardadas\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, CoverageComponent_div_23_div_3_Template, 18, 13, \"div\", 23);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.savedPolygons);\n  }\n}\nexport let CoverageComponent = /*#__PURE__*/(() => {\n  class CoverageComponent {\n    constructor(hereMapsService, http, polygonAnalysisService) {\n      this.hereMapsService = hereMapsService;\n      this.http = http;\n      this.polygonAnalysisService = polygonAnalysisService;\n      this.currentPolygonName = '';\n      this.isDrawing = false;\n      this.currentPoints = [];\n      this.savedPolygons = [];\n      this.successMessage = '';\n      this.errorMessage = '';\n      this.currentMarkers = [];\n      this.currentPolygon = null;\n      this.editingPolygon = null;\n      this.editablePolygonRef = null;\n      this.mapClickAnalysis = null;\n      this.mapClickMarker = null;\n    }\n    ngOnInit() {\n      this.initializeMap();\n      setTimeout(() => {\n        this.loadSavedPolygons();\n      }, 1000);\n    }\n    ngOnDestroy() {\n      this.clearCurrentDrawing();\n    }\n    initializeMap() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        if (!_this.mapContainer?.nativeElement) {\n          setTimeout(() => _this.initializeMap(), 1000);\n          return;\n        }\n        const defaultCenter = {\n          lat: 19.4326,\n          lng: -99.1332\n        };\n        try {\n          const mapInstance = yield _this.hereMapsService.createMap(_this.mapContainer.nativeElement, defaultCenter, 12);\n          _this.map = mapInstance.map;\n          _this.ui = mapInstance.ui;\n          _this.behavior = mapInstance.behavior;\n          _this.setupMapEvents();\n          _this.clearMessages();\n        } catch (error) {\n          _this.errorMessage = `Error al inicializar el mapa: ${error instanceof Error ? error.message : 'Error desconocido'}`;\n        }\n      })();\n    }\n    setupMapEvents() {\n      if (!this.map) return;\n      this.map.addEventListener('tap', evt => {\n        try {\n          const coord = this.map.screenToGeo(evt.currentPointer.viewportX, evt.currentPointer.viewportY);\n          if (coord && coord.hasOwnProperty('lat') && coord.hasOwnProperty('lng') && typeof coord.lat === 'number' && typeof coord.lng === 'number' && !isNaN(coord.lat) && !isNaN(coord.lng)) {\n            // Si hay un polígono en modo editable, agregar puntos a él\n            if (this.editablePolygonRef && this.editablePolygonRef.editable) {\n              this.addPointToEditablePolygon(coord.lat, coord.lng);\n              return;\n            }\n            // Comportamiento para crear nuevos polígonos\n            if (this.isDrawing) {\n              this.addPointToCurrentPolygon(coord.lat, coord.lng);\n              return;\n            }\n            // Análisis de polígono para punto clickeado\n            this.analyzeMapPoint(coord.lat, coord.lng);\n          } else {\n            console.error('Coordenadas inválidas del mapa:', coord);\n            this.errorMessage = 'Error: coordenadas inválidas obtenidas del mapa';\n          }\n        } catch (error) {\n          console.error('Error obteniendo coordenadas del mapa:', error);\n        }\n      });\n      this.map.addEventListener('dbltap', evt => {\n        if (!this.isDrawing || this.currentPoints.length < 3) return;\n        evt.stopPropagation();\n        this.completeCurrentPolygon();\n      });\n    }\n    startDrawing() {\n      if (!this.currentPolygonName.trim()) {\n        this.errorMessage = 'Ingresa un nombre para el área de cobertura';\n        return;\n      }\n      // Si hay un polígono en modo editable, desactivarlo primero\n      if (this.editablePolygonRef && this.editablePolygonRef.editable) {\n        this.editablePolygonRef.editable = false;\n        this.createPolygonOnMap(this.editablePolygonRef);\n        this.editablePolygonRef = null;\n      }\n      this.isDrawing = true;\n      this.currentPoints = [];\n      this.clearCurrentDrawing();\n      this.clearMessages();\n    }\n    cancelDrawing() {\n      this.isDrawing = false;\n      this.clearCurrentDrawing();\n      this.editingPolygon = null;\n    }\n    addPointToCurrentPolygon(lat, lng) {\n      if (typeof lat !== 'number' || typeof lng !== 'number' || isNaN(lat) || isNaN(lng)) {\n        console.error('Coordenadas inválidas:', {\n          lat,\n          lng\n        });\n        this.errorMessage = 'Error: coordenadas inválidas para agregar punto';\n        return;\n      }\n      // Validación adicional de rangos\n      if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {\n        console.error('Coordenadas fuera de rango:', {\n          lat,\n          lng\n        });\n        this.errorMessage = 'Error: coordenadas fuera del rango válido';\n        return;\n      }\n      const point = {\n        lat: Number(lat),\n        lng: Number(lng)\n      };\n      this.currentPoints.push(point);\n      try {\n        const marker = this.hereMapsService.addMarker(this.map, point, {\n          icon: new H.map.Icon(`<svg width=\"24\" height=\"24\" xmlns=\"http://www.w3.org/2000/svg\">\n          <circle cx=\"12\" cy=\"12\" r=\"8\" fill=\"red\" stroke=\"white\" stroke-width=\"3\"/>\n          <text x=\"12\" y=\"17\" text-anchor=\"middle\" fill=\"white\" font-size=\"10\" font-weight=\"bold\">${this.currentPoints.length}</text>\n        </svg>`, {\n            size: {\n              w: 24,\n              h: 24\n            }\n          })\n        });\n        this.currentMarkers.push(marker);\n        this.updateCurrentPolygonDisplay();\n        this.clearMessages(); // Limpiar mensajes de error anteriores\n      } catch (error) {\n        console.error('Error creando marcador:', error);\n        this.errorMessage = 'Error agregando marcador al mapa';\n        this.currentPoints.pop(); // Remover el punto si falló agregar el marcador\n      }\n    }\n    // Agregar punto a un polígono editable existente\n    addPointToEditablePolygon(lat, lng) {\n      if (!this.editablePolygonRef) return;\n      if (typeof lat !== 'number' || typeof lng !== 'number' || isNaN(lat) || isNaN(lng)) {\n        console.error('Coordenadas inválidas para polígono editable:', {\n          lat,\n          lng\n        });\n        return;\n      }\n      if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {\n        console.error('Coordenadas fuera de rango para polígono editable:', {\n          lat,\n          lng\n        });\n        return;\n      }\n      const newPoint = {\n        lat: Number(lat),\n        lng: Number(lng)\n      };\n      // Encontrar el mejor lugar para insertar el nuevo punto\n      // (buscar la arista más cercana al clic y insertar ahí)\n      const insertIndex = this.findBestInsertionIndex(newPoint, this.editablePolygonRef.coordinates);\n      // Agregar el punto a las coordenadas del polígono\n      this.editablePolygonRef.coordinates.splice(insertIndex, 0, newPoint);\n      // Recrear el polígono editable con los nuevos puntos\n      this.createPolygonOnMap(this.editablePolygonRef);\n      this.successMessage = `Punto agregado al polígono \"${this.editablePolygonRef.name}\" (${this.editablePolygonRef.coordinates.length} puntos total)`;\n      this.clearMessagesAfterDelay(3000);\n    }\n    // Eliminar punto de un polígono editable\n    removePointFromEditablePolygon(pointIndex) {\n      if (!this.editablePolygonRef || this.editablePolygonRef.coordinates.length <= 3) {\n        return; // Mantener al menos 3 puntos para un polígono válido\n      }\n      // Eliminar el punto de las coordenadas\n      this.editablePolygonRef.coordinates.splice(pointIndex, 1);\n      // Recrear el polígono editable con los puntos actualizados\n      this.createPolygonOnMap(this.editablePolygonRef);\n      this.successMessage = `Punto eliminado del polígono \"${this.editablePolygonRef.name}\" (${this.editablePolygonRef.coordinates.length} puntos restantes)`;\n      this.clearMessagesAfterDelay(3000);\n    }\n    // Encontrar el mejor índice para insertar un nuevo punto\n    findBestInsertionIndex(newPoint, coordinates) {\n      if (coordinates.length < 2) return coordinates.length;\n      let minDistance = Infinity;\n      let bestIndex = coordinates.length;\n      // Calcular distancia a cada arista y encontrar la más cercana\n      for (let i = 0; i < coordinates.length; i++) {\n        const p1 = coordinates[i];\n        const p2 = coordinates[(i + 1) % coordinates.length]; // Siguiente punto (circular)\n        const distanceToEdge = this.distancePointToLineSegment(newPoint, p1, p2);\n        if (distanceToEdge < minDistance) {\n          minDistance = distanceToEdge;\n          bestIndex = i + 1; // Insertar después del primer punto de la arista\n        }\n      }\n      return bestIndex;\n    }\n    // Calcular distancia de un punto a un segmento de línea\n    distancePointToLineSegment(point, lineStart, lineEnd) {\n      const A = point.lat - lineStart.lat;\n      const B = point.lng - lineStart.lng;\n      const C = lineEnd.lat - lineStart.lat;\n      const D = lineEnd.lng - lineStart.lng;\n      const dot = A * C + B * D;\n      const lenSq = C * C + D * D;\n      if (lenSq === 0) {\n        // Los puntos de línea son idénticos\n        return Math.sqrt(A * A + B * B);\n      }\n      let param = dot / lenSq;\n      let xx, yy;\n      if (param < 0) {\n        xx = lineStart.lat;\n        yy = lineStart.lng;\n      } else if (param > 1) {\n        xx = lineEnd.lat;\n        yy = lineEnd.lng;\n      } else {\n        xx = lineStart.lat + param * C;\n        yy = lineStart.lng + param * D;\n      }\n      const dx = point.lat - xx;\n      const dy = point.lng - yy;\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n    updateCurrentPolygonDisplay() {\n      if (this.currentPoints.length < 2) return;\n      if (this.currentPolygon) {\n        this.map.removeObject(this.currentPolygon);\n      }\n      if (this.currentPoints.length >= 3) {\n        try {\n          // Usar polígono editable durante la creación\n          this.currentPolygon = this.createEditablePolygon(this.currentPoints);\n          this.map.addObject(this.currentPolygon);\n          this.clearMessages(); // Limpiar mensajes de error previos\n        } catch (error) {\n          console.error('Error creando polígono:', error);\n          this.errorMessage = `Error al mostrar polígono: ${error instanceof Error ? error.message : 'Error desconocido'}`;\n        }\n      }\n    }\n    completeCurrentPolygon() {\n      if (this.currentPoints.length < 3) {\n        this.errorMessage = 'Se necesitan al menos 3 puntos para crear un polígono';\n        return;\n      }\n      this.updateCurrentPolygonDisplay();\n    }\n    canSavePolygon() {\n      return this.currentPoints.length >= 3 && this.currentPolygonName.trim() !== '';\n    }\n    saveCurrentPolygon() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        if (!_this2.canSavePolygon()) {\n          _this2.errorMessage = 'Se necesitan al menos 3 puntos y un nombre para guardar el polígono';\n          return;\n        }\n        const polygon = {\n          id: _this2.editingPolygon ? _this2.editingPolygon.id : _this2.generateId(),\n          name: _this2.currentPolygonName.trim(),\n          coordinates: [..._this2.currentPoints],\n          created: _this2.editingPolygon ? _this2.editingPolygon.created : new Date(),\n          updated: new Date()\n        };\n        try {\n          if (_this2.editingPolygon) {\n            yield _this2.updatePolygon(polygon);\n            _this2.successMessage = `Área \"${polygon.name}\" actualizada correctamente`;\n          } else {\n            yield _this2.createPolygon(polygon);\n            _this2.successMessage = `Área \"${polygon.name}\" guardada correctamente`;\n          }\n          _this2.resetDrawing();\n          _this2.loadSavedPolygons();\n          _this2.clearMessagesAfterDelay();\n        } catch (error) {\n          _this2.errorMessage = `Error al guardar el área: ${error instanceof Error ? error.message : 'Error desconocido'}`;\n        }\n      })();\n    }\n    createPolygon(polygon) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        return new Promise((resolve, reject) => {\n          _this3.http.post('http://localhost:3000/api/coverage', polygon).subscribe({\n            next: () => resolve(),\n            error: error => reject(error?.message || 'Error del servidor')\n          });\n        });\n      })();\n    }\n    updatePolygon(polygon) {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        return new Promise((resolve, reject) => {\n          _this4.http.post(`http://localhost:3000/api/coverage/${polygon.id}`, polygon).subscribe({\n            next: () => resolve(),\n            error: error => reject(error?.message || 'Error del servidor')\n          });\n        });\n      })();\n    }\n    loadSavedPolygons() {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          _this5.http.get('http://localhost:3000/api/coverage').subscribe({\n            next: polygons => {\n              _this5.savedPolygons = polygons.map(p => ({\n                ...p,\n                visible: true\n              }));\n              _this5.displaySavedPolygons();\n              _this5.clearMessages();\n            },\n            error: error => {\n              if (error.status === 0) {\n                _this5.errorMessage = 'No se puede conectar con el servidor. Asegúrate de que el backend esté ejecutándose en http://localhost:3000';\n                setTimeout(() => {\n                  _this5.loadSavedPolygons();\n                }, 5000);\n              } else {\n                _this5.errorMessage = `Error cargando áreas de cobertura: ${error?.message || error?.statusText || 'Error desconocido'}`;\n              }\n              console.error('Error cargando polígonos:', error);\n            }\n          });\n        } catch (error) {\n          _this5.errorMessage = 'Error inesperado al cargar las áreas de cobertura.';\n          console.error('Error al cargar polígonos guardados:', error);\n        }\n      })();\n    }\n    displaySavedPolygons() {\n      if (!this.map) return;\n      this.savedPolygons.forEach(polygon => {\n        if (polygon.coordinates.length >= 3) {\n          this.createPolygonOnMap(polygon);\n        }\n      });\n    }\n    createPolygonOnMap(polygon) {\n      if (polygon.mapPolygon) {\n        this.map.removeObject(polygon.mapPolygon);\n      }\n      try {\n        // Crear polígono editable o regular según el estado\n        const mapPolygon = polygon.editable ? this.createEditablePolygon(polygon.coordinates, polygon) : this.createPolygonRobust(polygon.coordinates);\n        const color = this.getRandomColor();\n        if (polygon.editable) {\n          // Para polígonos editables, el estilo se aplica al polígono interno\n          const polygonObj = mapPolygon.getObjects().find(obj => obj instanceof H.map.Polygon);\n          if (polygonObj) {\n            polygonObj.setStyle({\n              strokeColor: `rgba(${color.r}, ${color.g}, ${color.b}, 0.8)`,\n              fillColor: `rgba(${color.r}, ${color.g}, ${color.b}, 0.3)`,\n              lineWidth: 2\n            });\n          }\n        } else {\n          mapPolygon.setStyle({\n            strokeColor: `rgba(${color.r}, ${color.g}, ${color.b}, 0.8)`,\n            fillColor: `rgba(${color.r}, ${color.g}, ${color.b}, 0.3)`,\n            lineWidth: 2\n          });\n        }\n        polygon.mapPolygon = mapPolygon;\n        if (polygon.visible !== false) {\n          this.map.addObject(polygon.mapPolygon);\n        }\n      } catch (error) {\n        console.error(`Error creando polígono para ${polygon.name}:`, error);\n      }\n    }\n    // Editar propiedades del polígono (nombre)\n    editPolygonProperties(polygon) {\n      const newName = prompt('Ingrese el nuevo nombre para el área:', polygon.name);\n      if (newName && newName.trim() && newName.trim() !== polygon.name) {\n        this.updatePolygonName(polygon, newName.trim());\n      }\n    }\n    // Activar/desactivar modo de edición de forma del polígono\n    toggleEditableMode(polygon) {\n      polygon.editable = !polygon.editable;\n      if (polygon.editable) {\n        // Establecer referencia al polígono editable\n        this.editablePolygonRef = polygon;\n        // Desactivar modo de dibujo normal si estaba activo\n        this.isDrawing = false;\n        this.clearCurrentDrawing();\n        this.successMessage = `Modo de edición activado para \"${polygon.name}\". Haz clic en el mapa para agregar puntos, arrastra los círculos rojos para mover puntos, o doble clic en círculos para eliminar puntos.`;\n        this.clearMessagesAfterDelay(8000);\n      } else {\n        // Limpiar referencia al polígono editable\n        this.editablePolygonRef = null;\n        // Cuando se finaliza la edición, obtener las coordenadas actualizadas y guardar\n        this.savePolygonChanges(polygon);\n        this.successMessage = `Edición finalizada para \"${polygon.name}\".`;\n        this.clearMessagesAfterDelay();\n      }\n      // Recrear el polígono con el nuevo modo\n      this.createPolygonOnMap(polygon);\n    }\n    // Actualizar solo el nombre del polígono\n    updatePolygonName(polygon, newName) {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          const updatedPolygon = _this6.cleanPolygonForServer({\n            ...polygon,\n            name: newName,\n            updated: new Date()\n          });\n          yield new Promise((resolve, reject) => {\n            _this6.http.post(`http://localhost:3000/api/coverage/${polygon.id}`, updatedPolygon).subscribe({\n              next: () => resolve(null),\n              error: error => reject(error)\n            });\n          });\n          // Actualizar en la lista local\n          const index = _this6.savedPolygons.findIndex(p => p.id === polygon.id);\n          if (index !== -1) {\n            _this6.savedPolygons[index].name = newName;\n            _this6.savedPolygons[index].updated = updatedPolygon.updated;\n          }\n          _this6.successMessage = `Nombre actualizado a \"${newName}\"`;\n          _this6.clearMessagesAfterDelay();\n        } catch (error) {\n          _this6.errorMessage = `Error actualizando nombre: ${error instanceof Error ? error.message : 'Error desconocido'}`;\n        }\n      })();\n    }\n    // Guardar cambios de forma del polígono\n    savePolygonChanges(polygon) {\n      var _this7 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          // Obtener coordenadas actualizadas del polígono en el mapa\n          if (polygon.mapPolygon) {\n            const updatedCoordinates = _this7.extractCoordinatesFromMapPolygon(polygon.mapPolygon);\n            // Crear objeto limpio sin propiedades que causan referencias circulares\n            const cleanPolygon = _this7.cleanPolygonForServer({\n              ...polygon,\n              coordinates: updatedCoordinates,\n              updated: new Date()\n            });\n            yield new Promise((resolve, reject) => {\n              _this7.http.post(`http://localhost:3000/api/coverage/${polygon.id}`, cleanPolygon).subscribe({\n                next: () => resolve(null),\n                error: error => reject(error)\n              });\n            });\n            // Actualizar en la lista local\n            const index = _this7.savedPolygons.findIndex(p => p.id === polygon.id);\n            if (index !== -1) {\n              _this7.savedPolygons[index].coordinates = updatedCoordinates;\n              _this7.savedPolygons[index].updated = cleanPolygon.updated;\n            }\n          }\n        } catch (error) {\n          console.error('Error guardando cambios del polígono:', error);\n          _this7.errorMessage = `Error guardando cambios: ${error instanceof Error ? error.message : 'Error desconocido'}`;\n        }\n      })();\n    }\n    // Extraer coordenadas del polígono en el mapa\n    extractCoordinatesFromMapPolygon(mapPolygon) {\n      const coordinates = [];\n      try {\n        // Si es un grupo (polígono editable), obtener el polígono interno\n        let polygon = mapPolygon;\n        if (mapPolygon.getObjects) {\n          polygon = mapPolygon.getObjects().find(obj => obj instanceof H.map.Polygon);\n        }\n        if (polygon && polygon.getGeometry) {\n          const exterior = polygon.getGeometry().getExterior();\n          exterior.eachLatLngAlt((lat, lng) => {\n            coordinates.push({\n              lat,\n              lng\n            });\n          });\n        }\n      } catch (error) {\n        console.error('Error extrayendo coordenadas:', error);\n      }\n      return coordinates;\n    }\n    // Función original editPolygon renombrada para compatibilidad\n    editPolygonCoordinates(polygon) {\n      this.editingPolygon = polygon;\n      this.currentPolygonName = polygon.name;\n      this.currentPoints = [...polygon.coordinates];\n      this.isDrawing = true;\n      this.clearCurrentDrawing();\n      this.currentPoints.forEach((point, index) => {\n        const marker = this.hereMapsService.addMarker(this.map, point, {\n          icon: new H.map.Icon(`<svg width=\"24\" height=\"24\" xmlns=\"http://www.w3.org/2000/svg\">\n            <circle cx=\"12\" cy=\"12\" r=\"8\" fill=\"blue\" stroke=\"white\" stroke-width=\"3\"/>\n            <text x=\"12\" y=\"17\" text-anchor=\"middle\" fill=\"white\" font-size=\"10\" font-weight=\"bold\">${index + 1}</text>\n          </svg>`, {\n            size: {\n              w: 24,\n              h: 24\n            }\n          })\n        });\n        this.currentMarkers.push(marker);\n      });\n      this.updateCurrentPolygonDisplay();\n      this.map.setCenter(polygon.coordinates[0]);\n      this.clearMessages();\n    }\n    togglePolygonVisibility(polygon) {\n      polygon.visible = !polygon.visible;\n      if (polygon.visible) {\n        if (polygon.mapPolygon) {\n          this.map.addObject(polygon.mapPolygon);\n        }\n      } else {\n        if (polygon.mapPolygon) {\n          this.map.removeObject(polygon.mapPolygon);\n        }\n      }\n    }\n    deletePolygon(polygonId) {\n      var _this8 = this;\n      return _asyncToGenerator(function* () {\n        if (!confirm('¿Estás seguro de que quieres eliminar esta área de cobertura?')) {\n          return;\n        }\n        try {\n          yield new Promise((resolve, reject) => {\n            _this8.http.post(`http://localhost:3000/api/coverage/delete/${polygonId}`, {}).subscribe({\n              next: () => resolve(null),\n              error: error => reject(error)\n            });\n          });\n          const polygonIndex = _this8.savedPolygons.findIndex(p => p.id === polygonId);\n          if (polygonIndex !== -1) {\n            const polygon = _this8.savedPolygons[polygonIndex];\n            if (polygon.mapPolygon) {\n              _this8.map.removeObject(polygon.mapPolygon);\n            }\n            _this8.savedPolygons.splice(polygonIndex, 1);\n          }\n          _this8.successMessage = 'Área eliminada correctamente';\n          _this8.clearMessagesAfterDelay();\n        } catch (error) {\n          _this8.errorMessage = `Error al eliminar el área: ${error instanceof Error ? error.message : 'Error desconocido'}`;\n        }\n      })();\n    }\n    resetDrawing() {\n      this.isDrawing = false;\n      this.currentPolygonName = '';\n      this.currentPoints = [];\n      this.editingPolygon = null;\n      this.clearCurrentDrawing();\n    }\n    clearCurrentDrawing() {\n      if (!this.map) return;\n      this.currentMarkers.forEach(marker => {\n        this.map.removeObject(marker);\n      });\n      this.currentMarkers = [];\n      if (this.currentPolygon) {\n        this.map.removeObject(this.currentPolygon);\n        this.currentPolygon = null;\n      }\n      this.clearMapClickAnalysis();\n    }\n    generateId() {\n      return Date.now().toString(36) + Math.random().toString(36).substr(2);\n    }\n    getRandomColor() {\n      return {\n        r: Math.floor(Math.random() * 128) + 128,\n        g: Math.floor(Math.random() * 128) + 64,\n        b: Math.floor(Math.random() * 128) + 128\n      };\n    }\n    clearMessages() {\n      this.successMessage = '';\n      this.errorMessage = '';\n    }\n    clearMessagesAfterDelay(delay = 3000) {\n      setTimeout(() => {\n        this.clearMessages();\n      }, delay);\n    }\n    validateAndCleanPoints(points) {\n      const cleaned = points.filter(point => {\n        if (!point) {\n          console.warn('Punto nulo o undefined filtrado:', point);\n          return false;\n        }\n        if (typeof point.lat !== 'number' || typeof point.lng !== 'number') {\n          console.warn('Punto con tipos incorrectos filtrado:', point, typeof point.lat, typeof point.lng);\n          return false;\n        }\n        if (isNaN(point.lat) || isNaN(point.lng)) {\n          console.warn('Punto con NaN filtrado:', point);\n          return false;\n        }\n        if (point.lat < -90 || point.lat > 90 || point.lng < -180 || point.lng > 180) {\n          console.warn('Punto fuera de rango filtrado:', point);\n          return false;\n        }\n        return true;\n      });\n      if (cleaned.length !== points.length) {\n        console.log(`validateAndCleanPoints: ${points.length - cleaned.length} puntos filtrados de ${points.length}`);\n      }\n      return cleaned;\n    }\n    safeCreateLineString(points) {\n      const validPoints = this.validateAndCleanPoints(points);\n      if (validPoints.length < 3) {\n        throw new Error(`Insuficientes puntos válidos: ${validPoints.length}. Se necesitan al menos 3.`);\n      }\n      const lineString = new H.geo.LineString();\n      validPoints.forEach((point, index) => {\n        // Extraer coordenadas a variables locales\n        const lat = Number(point.lat);\n        const lng = Number(point.lng);\n        if (typeof lat !== 'number' || typeof lng !== 'number' || isNaN(lat) || isNaN(lng)) {\n          console.error('Coordenadas extraídas inválidas en punto', index, {\n            lat,\n            lng\n          });\n          return;\n        }\n        try {\n          lineString.pushPoint(lat, lng);\n        } catch (error) {\n          console.error(`Error en pushPoint con punto ${index}:`, {\n            lat,\n            lng\n          }, error);\n          throw error;\n        }\n      });\n      const firstPoint = validPoints[0];\n      const firstLat = Number(firstPoint.lat);\n      const firstLng = Number(firstPoint.lng);\n      if (typeof firstLat !== 'number' || typeof firstLng !== 'number' || isNaN(firstLat) || isNaN(firstLng)) {\n        console.error('Coordenadas primer punto inválidas:', {\n          firstLat,\n          firstLng\n        });\n        throw new Error('Primer punto inválido para cerrar polígono');\n      }\n      try {\n        lineString.pushPoint(firstLat, firstLng);\n      } catch (error) {\n        console.error('Error cerrando polígono:', {\n          firstLat,\n          firstLng\n        }, error);\n        throw error;\n      }\n      return lineString;\n    }\n    // Método usando el patrón oficial de HERE Maps\n    createPolygonRobust(points) {\n      // Filtrar y limpiar puntos\n      const safePoints = points.filter(p => p && typeof p.lat === 'number' && typeof p.lng === 'number').filter(p => !isNaN(p.lat) && !isNaN(p.lng)).filter(p => p.lat >= -90 && p.lat <= 90 && p.lng >= -180 && p.lng <= 180);\n      if (safePoints.length < 3) {\n        throw new Error(`Insuficientes puntos válidos: ${safePoints.length}`);\n      }\n      // Crear array de coordenadas en formato [lat, lng, alt, lat, lng, alt, ...]\n      // como especifica la documentación oficial de HERE Maps\n      const coordinates = [];\n      for (const point of safePoints) {\n        const lat = Number(point.lat);\n        const lng = Number(point.lng);\n        if (isFinite(lat) && isFinite(lng)) {\n          coordinates.push(lat, lng, 0); // Agregar altitud 0 como en el ejemplo oficial\n        }\n      }\n      try {\n        // Usar el patrón exacto del código oficial de HERE Maps\n        const polygon = new H.map.Polygon(new H.geo.Polygon(new H.geo.LineString(coordinates)), {\n          style: {\n            fillColor: 'rgba(255, 0, 0, 0.3)',\n            strokeColor: 'rgba(255, 0, 0, 0.8)',\n            lineWidth: 3\n          }\n        });\n        return polygon;\n      } catch (error) {\n        console.error('Error creando polígono HERE Maps:', error, 'Coordenadas:', coordinates);\n        throw new Error(`Error creando polígono: ${error instanceof Error ? error.message : 'Error desconocido'}`);\n      }\n    }\n    // Crear polígono editable con vértices arrastrables (basado en código oficial HERE Maps)\n    createEditablePolygon(points, polygonRef) {\n      const safePoints = points.filter(p => p && typeof p.lat === 'number' && typeof p.lng === 'number').filter(p => !isNaN(p.lat) && !isNaN(p.lng)).filter(p => p.lat >= -90 && p.lat <= 90 && p.lng >= -180 && p.lng <= 180);\n      if (safePoints.length < 3) {\n        throw new Error(`Insuficientes puntos válidos: ${safePoints.length}`);\n      }\n      // Crear array de coordenadas para HERE Maps\n      const coordinates = [];\n      for (const point of safePoints) {\n        coordinates.push(Number(point.lat), Number(point.lng), 0);\n      }\n      // SVG para los vértices editables (basado en código oficial)\n      const svgCircle = '<svg width=\"20\" height=\"20\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">' + '<circle cx=\"10\" cy=\"10\" r=\"7\" fill=\"transparent\" stroke=\"red\" stroke-width=\"4\"/>' + '</svg>';\n      // Crear polígono principal\n      const polygon = new H.map.Polygon(new H.geo.Polygon(new H.geo.LineString(coordinates)), {\n        style: {\n          fillColor: 'rgba(255, 0, 0, 0.3)',\n          strokeColor: 'rgba(255, 0, 0, 0.8)',\n          lineWidth: 3\n        }\n      });\n      // Grupo para los vértices editables (inicialmente oculto)\n      const verticeGroup = new H.map.Group({\n        visibility: false\n      });\n      // Grupo principal que contiene el polígono y los vértices\n      const mainGroup = new H.map.Group({\n        volatility: true,\n        // Para movimiento suave de arrastre\n        objects: [polygon, verticeGroup]\n      });\n      polygon.draggable = true;\n      // Limpiar vértices existentes antes de recrear\n      verticeGroup.removeAll();\n      // Crear marcadores para cada vértice del polígono\n      polygon.getGeometry().getExterior().eachLatLngAlt((lat, lng, alt, index) => {\n        const vertice = new H.map.Marker({\n          lat,\n          lng\n        }, {\n          icon: new H.map.Icon(svgCircle, {\n            anchor: {\n              x: 10,\n              y: 10\n            }\n          })\n        });\n        vertice.draggable = true;\n        vertice.setData({\n          verticeIndex: index\n        });\n        // Agregar evento de doble clic para eliminar vértice\n        vertice.addEventListener('dbltap', evt => {\n          evt.stopPropagation();\n          if (polygonRef && polygonRef.coordinates.length > 3) {\n            // Mantener al menos 3 puntos\n            const verticeIndex = evt.target.getData()['verticeIndex'];\n            this.removePointFromEditablePolygon(verticeIndex);\n          } else {\n            this.errorMessage = 'Un polígono debe tener al menos 3 puntos.';\n            this.clearMessagesAfterDelay();\n          }\n        }, true);\n        verticeGroup.addObject(vertice);\n      });\n      // Timeout para manejar la visibilidad de vértices en touch devices\n      let polygonTimeout;\n      // Mostrar vértices al pasar mouse sobre el polígono\n      mainGroup.addEventListener('pointerenter', () => {\n        if (polygonTimeout) {\n          clearTimeout(polygonTimeout);\n          polygonTimeout = null;\n        }\n        verticeGroup.setVisibility(true);\n      }, true);\n      // Ocultar vértices al salir con mouse\n      mainGroup.addEventListener('pointerleave', evt => {\n        const timeout = evt.currentPointer.type === 'touch' ? 1000 : 0;\n        polygonTimeout = setTimeout(() => {\n          verticeGroup.setVisibility(false);\n        }, timeout);\n      }, true);\n      // Cambiar cursor al pasar sobre vértices\n      verticeGroup.addEventListener('pointerenter', () => {\n        document.body.style.cursor = 'pointer';\n      }, true);\n      verticeGroup.addEventListener('pointerleave', () => {\n        document.body.style.cursor = 'default';\n      }, true);\n      // Manejar arrastre de vértices para redimensionar el polígono\n      verticeGroup.addEventListener('drag', evt => {\n        const pointer = evt.currentPointer;\n        const geoLineString = polygon.getGeometry().getExterior();\n        const geoPoint = this.map.screenToGeo(pointer.viewportX, pointer.viewportY);\n        // Actualizar posición del marcador de vértice\n        evt.target.setGeometry(geoPoint);\n        // Actualizar posición del vértice en el polígono\n        const verticeIndex = evt.target.getData()['verticeIndex'];\n        geoLineString.removePoint(verticeIndex);\n        geoLineString.insertPoint(verticeIndex, geoPoint);\n        polygon.setGeometry(new H.geo.Polygon(geoLineString));\n        // Actualizar nuestro array de puntos actual\n        if (this.isDrawing && this.currentPoints[verticeIndex]) {\n          this.currentPoints[verticeIndex] = {\n            lat: geoPoint.lat,\n            lng: geoPoint.lng\n          };\n        }\n        // Actualizar coordenadas del polígono guardado si está en modo edición\n        if (polygonRef && polygonRef.coordinates[verticeIndex]) {\n          polygonRef.coordinates[verticeIndex] = {\n            lat: geoPoint.lat,\n            lng: geoPoint.lng\n          };\n        }\n        // Detener propagación para que no se mueva el mapa\n        evt.stopPropagation();\n      }, true);\n      return mainGroup;\n    }\n    // Verificar si hay polígonos en modo de edición\n    hasEditablePolygons() {\n      return this.savedPolygons.some(polygon => polygon.editable);\n    }\n    // Limpiar objeto polígono para envío al servidor (eliminar propiedades que causan referencias circulares)\n    cleanPolygonForServer(polygon) {\n      return {\n        id: polygon.id,\n        name: polygon.name,\n        coordinates: polygon.coordinates,\n        created: polygon.created,\n        updated: polygon.updated\n      };\n    }\n    analyzeMapPoint(lat, lng) {\n      this.polygonAnalysisService.analyzeMapPoint(lat, lng).subscribe({\n        next: result => {\n          this.mapClickAnalysis = result;\n          this.showMapClickMarker(lat, lng, result);\n        },\n        error: error => {\n          console.error('Error analizando punto del mapa:', error);\n          this.errorMessage = `Error analizando punto: ${error.error?.error || error.message || 'Error desconocido'}`;\n          this.clearMessagesAfterDelay();\n        }\n      });\n    }\n    showMapClickMarker(lat, lng, analysis) {\n      if (this.mapClickMarker) {\n        this.map.removeObject(this.mapClickMarker);\n      }\n      let iconColor = 'blue';\n      let statusText = '?';\n      if (analysis.status === 'inside') {\n        iconColor = 'green';\n        statusText = '✓';\n      } else if (analysis.status === 'outside') {\n        iconColor = 'orange';\n        statusText = '→';\n      } else {\n        iconColor = 'red';\n        statusText = '✗';\n      }\n      this.mapClickMarker = this.hereMapsService.addMarker(this.map, {\n        lat,\n        lng\n      }, {\n        icon: new H.map.Icon(`<svg width=\"28\" height=\"28\" xmlns=\"http://www.w3.org/2000/svg\">\n          <circle cx=\"14\" cy=\"14\" r=\"12\" fill=\"${iconColor}\" stroke=\"white\" stroke-width=\"3\"/>\n          <text x=\"14\" y=\"19\" text-anchor=\"middle\" fill=\"white\" font-size=\"12\" font-weight=\"bold\">${statusText}</text>\n        </svg>`, {\n          size: {\n            w: 28,\n            h: 28\n          }\n        })\n      });\n    }\n    clearMapClickAnalysis() {\n      this.mapClickAnalysis = null;\n      if (this.mapClickMarker) {\n        this.map.removeObject(this.mapClickMarker);\n        this.mapClickMarker = null;\n      }\n    }\n    centerMapOnAnalysis(analysis) {\n      if (this.map && analysis.coordinates) {\n        this.map.setCenter(analysis.coordinates);\n        this.map.setZoom(15);\n        this.showMapClickMarker(analysis.coordinates.lat, analysis.coordinates.lng, analysis);\n        this.mapClickAnalysis = analysis;\n      }\n    }\n    static {\n      this.ɵfac = function CoverageComponent_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || CoverageComponent)(i0.ɵɵdirectiveInject(i1.HereMapsService), i0.ɵɵdirectiveInject(i2.HttpClient), i0.ɵɵdirectiveInject(i3.PolygonAnalysisService));\n      };\n    }\n    static {\n      this.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n        type: CoverageComponent,\n        selectors: [[\"app-coverage\"]],\n        viewQuery: function CoverageComponent_Query(rf, ctx) {\n          if (rf & 1) {\n            i0.ɵɵviewQuery(_c0, 7);\n          }\n          if (rf & 2) {\n            let _t;\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.mapContainer = _t.first);\n          }\n        },\n        standalone: true,\n        features: [i0.ɵɵStandaloneFeature],\n        decls: 24,\n        vars: 11,\n        consts: [[\"coverageMap\", \"\"], [1, \"card\"], [1, \"alert\", \"alert-info\"], [1, \"form-group\"], [\"for\", \"polygonName\"], [\"id\", \"polygonName\", \"type\", \"text\", \"placeholder\", \"Ingresa el nombre del \\u00E1rea\", 1, \"form-control\", 3, \"ngModelChange\", \"ngModel\", \"disabled\"], [1, \"btn\", \"btn-primary\", 3, \"click\", \"disabled\"], [1, \"btn\", \"btn-secondary\", 2, \"margin-left\", \"10px\", 3, \"click\", \"disabled\"], [1, \"btn\", \"btn-success\", 2, \"margin-left\", \"10px\", 3, \"click\", \"disabled\"], [\"class\", \"alert alert-success\", 4, \"ngIf\"], [\"class\", \"alert alert-error\", 4, \"ngIf\"], [\"class\", \"alert alert-info\", 4, \"ngIf\"], [1, \"map-container\", 2, \"height\", \"500px\", \"border\", \"2px solid #ddd\"], [\"class\", \"alert alert-info\", \"style\", \"margin-top: 10px;\", 4, \"ngIf\"], [2, \"margin-top\", \"20px\", \"display\", \"block\", 3, \"showOnMap\"], [\"class\", \"card\", \"style\", \"margin-top: 20px;\", 4, \"ngIf\"], [1, \"alert\", \"alert-success\"], [1, \"alert\", \"alert-error\"], [1, \"alert\", \"alert-info\", 2, \"margin-top\", \"10px\"], [4, \"ngIf\"], [2, \"font-size\", \"12px\", \"color\", \"#666\", \"margin-top\", \"5px\"], [1, \"btn\", \"btn-sm\", \"btn-secondary\", 2, \"margin-top\", \"10px\", 3, \"click\"], [1, \"card\", 2, \"margin-top\", \"20px\"], [\"class\", \"polygon-item\", \"style\", \"padding: 15px; border: 1px solid #ddd; margin: 10px 0; border-radius: 4px; background-color: #f8f9fa;\", 4, \"ngFor\", \"ngForOf\"], [1, \"polygon-item\", 2, \"padding\", \"15px\", \"border\", \"1px solid #ddd\", \"margin\", \"10px 0\", \"border-radius\", \"4px\", \"background-color\", \"#f8f9fa\"], [2, \"display\", \"flex\", \"justify-content\", \"space-between\", \"align-items\", \"center\"], [2, \"margin\", \"0\", \"color\", \"#333\"], [2, \"margin\", \"5px 0\", \"font-size\", \"14px\", \"color\", \"#666\"], [\"style\", \"color: #28a745; font-weight: bold;\", 4, \"ngIf\"], [1, \"btn\", \"btn-info\", 2, \"margin-right\", \"5px\", \"font-size\", \"12px\", 3, \"click\"], [1, \"btn\", 2, \"margin-right\", \"5px\", \"font-size\", \"12px\", 3, \"click\"], [1, \"btn\", \"btn-warning\", 2, \"margin-right\", \"5px\", \"font-size\", \"12px\", 3, \"click\"], [1, \"btn\", \"btn-danger\", 2, \"font-size\", \"12px\", 3, \"click\"], [2, \"color\", \"#28a745\", \"font-weight\", \"bold\"]],\n        template: function CoverageComponent_Template(rf, ctx) {\n          if (rf & 1) {\n            const _r1 = i0.ɵɵgetCurrentView();\n            i0.ɵɵelementStart(0, \"div\", 1)(1, \"h2\");\n            i0.ɵɵtext(2, \"Gesti\\u00F3n de Cobertura\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(3, \"div\", 2);\n            i0.ɵɵtext(4, \" Haz clic en el mapa para crear puntos del pol\\u00EDgono. Haz doble clic para completar el pol\\u00EDgono. \");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(5, \"div\", 3)(6, \"label\", 4);\n            i0.ɵɵtext(7, \"Nombre del \\u00E1rea de cobertura:\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(8, \"input\", 5);\n            i0.ɵɵtwoWayListener(\"ngModelChange\", function CoverageComponent_Template_input_ngModelChange_8_listener($event) {\n              i0.ɵɵrestoreView(_r1);\n              i0.ɵɵtwoWayBindingSet(ctx.currentPolygonName, $event) || (ctx.currentPolygonName = $event);\n              return i0.ɵɵresetView($event);\n            });\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(9, \"div\", 3)(10, \"button\", 6);\n            i0.ɵɵlistener(\"click\", function CoverageComponent_Template_button_click_10_listener() {\n              i0.ɵɵrestoreView(_r1);\n              return i0.ɵɵresetView(ctx.startDrawing());\n            });\n            i0.ɵɵtext(11, \" Crear Nueva \\u00C1rea \");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(12, \"button\", 7);\n            i0.ɵɵlistener(\"click\", function CoverageComponent_Template_button_click_12_listener() {\n              i0.ɵɵrestoreView(_r1);\n              return i0.ɵɵresetView(ctx.cancelDrawing());\n            });\n            i0.ɵɵtext(13, \" Cancelar \");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(14, \"button\", 8);\n            i0.ɵɵlistener(\"click\", function CoverageComponent_Template_button_click_14_listener() {\n              i0.ɵɵrestoreView(_r1);\n              return i0.ɵɵresetView(ctx.saveCurrentPolygon());\n            });\n            i0.ɵɵtext(15);\n            i0.ɵɵelementEnd()();\n            i0.ɵɵtemplate(16, CoverageComponent_div_16_Template, 2, 1, \"div\", 9)(17, CoverageComponent_div_17_Template, 2, 1, \"div\", 10)(18, CoverageComponent_div_18_Template, 17, 0, \"div\", 11);\n            i0.ɵɵelement(19, \"div\", 12, 0);\n            i0.ɵɵtemplate(21, CoverageComponent_div_21_Template, 10, 5, \"div\", 13);\n            i0.ɵɵelementStart(22, \"app-address-search\", 14);\n            i0.ɵɵlistener(\"showOnMap\", function CoverageComponent_Template_app_address_search_showOnMap_22_listener($event) {\n              i0.ɵɵrestoreView(_r1);\n              return i0.ɵɵresetView(ctx.centerMapOnAnalysis($event));\n            });\n            i0.ɵɵelementEnd();\n            i0.ɵɵtemplate(23, CoverageComponent_div_23_Template, 4, 1, \"div\", 15);\n            i0.ɵɵelementEnd();\n          }\n          if (rf & 2) {\n            i0.ɵɵadvance(8);\n            i0.ɵɵtwoWayProperty(\"ngModel\", ctx.currentPolygonName);\n            i0.ɵɵproperty(\"disabled\", ctx.isDrawing);\n            i0.ɵɵadvance(2);\n            i0.ɵɵproperty(\"disabled\", ctx.isDrawing || !ctx.currentPolygonName.trim());\n            i0.ɵɵadvance(2);\n            i0.ɵɵproperty(\"disabled\", !ctx.isDrawing);\n            i0.ɵɵadvance(2);\n            i0.ɵɵproperty(\"disabled\", !ctx.canSavePolygon());\n            i0.ɵɵadvance();\n            i0.ɵɵtextInterpolate1(\" Guardar \\u00C1rea (\", ctx.currentPoints.length, \" puntos) \");\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.successMessage);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.errorMessage);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.hasEditablePolygons());\n            i0.ɵɵadvance(3);\n            i0.ɵɵproperty(\"ngIf\", ctx.mapClickAnalysis);\n            i0.ɵɵadvance(2);\n            i0.ɵɵproperty(\"ngIf\", ctx.savedPolygons.length > 0);\n          }\n        },\n        dependencies: [CommonModule, i4.NgForOf, i4.NgIf, i4.DatePipe, FormsModule, i5.DefaultValueAccessor, i5.NgControlStatus, i5.NgModel, AddressSearchComponent],\n        styles: [\".polygon-item[_ngcontent-%COMP%]:hover{background-color:#e9ecef!important}.alert-error[_ngcontent-%COMP%]{color:#721c24;background-color:#f8d7da;border-color:#f5c6cb;padding:.75rem 1.25rem;margin-bottom:1rem;border:1px solid;border-radius:.25rem}.alert-success[_ngcontent-%COMP%]{color:#155724;background-color:#d4edda;border-color:#c3e6cb;padding:.75rem 1.25rem;margin-bottom:1rem;border:1px solid;border-radius:.25rem}.alert-info[_ngcontent-%COMP%]{color:#0c5460;background-color:#d1ecf1;border-color:#bee5eb;padding:.75rem 1.25rem;margin-bottom:1rem;border:1px solid;border-radius:.25rem}\"]\n      });\n    }\n  }\n  return CoverageComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}