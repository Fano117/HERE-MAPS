{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Alfredo/Documents/HERE-MAPS/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport let HereMapsService = /*#__PURE__*/(() => {\n  class HereMapsService {\n    constructor() {\n      this.API_KEY = 'GYo3JTyTU2DjUu_dGyaDc2LIZyANv1zL5-Lot729yhw';\n      this.initialized = false;\n      this.currentLocationSubject = new BehaviorSubject(null);\n      this.currentLocation$ = this.currentLocationSubject.asObservable();\n      this.ensureInitialized();\n    }\n    ensureInitialized() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        if (_this.initialized) return;\n        try {\n          yield _this.waitForHereMaps();\n          _this.initializePlatform();\n          _this.initialized = true;\n        } catch (error) {\n          throw new Error(`Error al inicializar HERE Maps: ${error instanceof Error ? error.message : error}`);\n        }\n      })();\n    }\n    waitForHereMaps() {\n      return new Promise((resolve, reject) => {\n        const checkHereAPI = () => {\n          return typeof H !== 'undefined' && H && H.service && H.service.Platform && H.Map && H.mapevents && H.mapevents.Behavior && H.ui && H.ui.UI && H.map && H.map.Marker && H.map.Icon && window.hereMapsReady === true;\n        };\n        if (checkHereAPI()) {\n          resolve();\n          return;\n        }\n        const checkInterval = setInterval(() => {\n          if (checkHereAPI()) {\n            clearInterval(checkInterval);\n            resolve();\n          }\n        }, 50);\n        setTimeout(() => {\n          clearInterval(checkInterval);\n          if (checkHereAPI()) {\n            resolve();\n          } else {\n            reject(new Error('Timeout: HERE Maps API no se cargó correctamente'));\n          }\n        }, 20000);\n      });\n    }\n    initializePlatform() {\n      this.platform = new H.service.Platform({\n        'apikey': this.API_KEY\n      });\n      this.geocoder = this.platform.getSearchService();\n    }\n    geocodeAddress(query) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        yield _this2.ensureInitialized();\n        return new Promise((resolve, reject) => {\n          _this2.geocoder.geocode({\n            q: query\n          }, result => {\n            const addresses = result.items.map(item => ({\n              id: item.id,\n              label: item.address?.label || item.title,\n              houseNumber: item.address?.houseNumber,\n              street: item.address?.street,\n              district: item.address?.district,\n              city: item.address?.city,\n              postalCode: item.address?.postalCode,\n              countryName: item.address?.countryName,\n              coordinates: {\n                lat: item.position.lat,\n                lng: item.position.lng\n              }\n            }));\n            resolve(addresses);\n          }, error => {\n            reject(error);\n          });\n        });\n      })();\n    }\n    reverseGeocode(lat, lng) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        yield _this3.ensureInitialized();\n        return new Promise((resolve, reject) => {\n          _this3.geocoder.reverseGeocode({\n            at: `${lat},${lng}`\n          }, result => {\n            if (result.items && result.items.length > 0) {\n              const item = result.items[0];\n              const address = {\n                id: item.id,\n                label: item.address?.label || item.title,\n                houseNumber: item.address?.houseNumber,\n                street: item.address?.street,\n                district: item.address?.district,\n                city: item.address?.city,\n                postalCode: item.address?.postalCode,\n                countryName: item.address?.countryName,\n                coordinates: {\n                  lat: item.position.lat,\n                  lng: item.position.lng\n                }\n              };\n              resolve(address);\n            } else {\n              reject(new Error('No address found'));\n            }\n          }, error => {\n            reject(error);\n          });\n        });\n      })();\n    }\n    validateAddress(address) {\n      var _this4 = this;\n      return new Promise(/*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (resolve) {\n          try {\n            const results = yield _this4.geocodeAddress(address);\n            if (results.length > 0) {\n              const topResult = results[0];\n              const isExactMatch = _this4.isExactAddressMatch(address, topResult.label);\n              resolve({\n                isValid: isExactMatch,\n                suggestions: results\n              });\n            } else {\n              resolve({\n                isValid: false,\n                suggestions: []\n              });\n            }\n          } catch (error) {\n            resolve({\n              isValid: false,\n              suggestions: []\n            });\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    }\n    isExactAddressMatch(input, result) {\n      const normalizeString = str => {\n        return str.toLowerCase().replace(/[,\\.]/g, ' ').replace(/\\s+/g, ' ').trim();\n      };\n      const normalizedInput = normalizeString(input);\n      const normalizedResult = normalizeString(result);\n      return normalizedResult.includes(normalizedInput) || normalizedInput.includes(normalizedResult);\n    }\n    createMap(_x2, _x3) {\n      var _this5 = this;\n      return _asyncToGenerator(function* (container, center, zoom = 15) {\n        try {\n          yield _this5.ensureInitialized();\n          if (!container) {\n            throw new Error('Container del mapa no válido');\n          }\n          if (!_this5.platform) {\n            throw new Error('Platform no inicializada');\n          }\n          if (typeof H === 'undefined' || !H.Map) {\n            throw new Error('HERE Maps API no disponible');\n          }\n          let defaultLayers;\n          try {\n            defaultLayers = _this5.platform.createDefaultLayers();\n          } catch (error) {\n            throw new Error('No se pudieron crear las capas por defecto: ' + error);\n          }\n          if (!defaultLayers) {\n            throw new Error('defaultLayers es null o undefined');\n          }\n          if (!defaultLayers.vector) {\n            throw new Error('defaultLayers.vector no está disponible');\n          }\n          if (!defaultLayers.vector.normal) {\n            throw new Error('defaultLayers.vector.normal no está disponible');\n          }\n          if (!defaultLayers.vector.normal.map) {\n            throw new Error('defaultLayers.vector.normal.map no está disponible');\n          }\n          const mapLayer = defaultLayers.vector.normal.map;\n          let map;\n          try {\n            map = new H.Map(container, mapLayer, {\n              zoom: zoom,\n              center: {\n                lat: center.lat,\n                lng: center.lng\n              }\n            });\n          } catch (error) {\n            throw new Error('Error al crear instancia del mapa: ' + error);\n          }\n          if (!map) {\n            throw new Error('El mapa no se pudo crear');\n          }\n          let behavior;\n          try {\n            behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\n          } catch (error) {\n            throw new Error('Error al crear behavior: ' + error);\n          }\n          let ui;\n          try {\n            ui = H.ui.UI.createDefault(map, defaultLayers);\n          } catch (error) {\n            ui = null;\n          }\n          return {\n            map,\n            ui,\n            behavior\n          };\n        } catch (error) {\n          throw new Error(`Error al crear el mapa: ${error instanceof Error ? error.message : error}`);\n        }\n      }).apply(this, arguments);\n    }\n    addMarker(map, coordinates, options) {\n      const marker = new H.map.Marker(coordinates, options);\n      map.addObject(marker);\n      return marker;\n    }\n    removeMarkerSafely(map, marker) {\n      if (!map || !marker) return;\n      try {\n        const objects = map.getObjects();\n        if (objects && objects.indexOf(marker) !== -1) {\n          map.removeObject(marker);\n        }\n      } catch (error) {\n        // Ignorar errores de remoción\n      }\n    }\n    updateLocation(locationUpdate) {\n      this.currentLocationSubject.next(locationUpdate);\n    }\n    getCurrentLocation() {\n      return this.currentLocationSubject.value;\n    }\n    calculateRoute(origin, destination) {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        yield _this6.ensureInitialized();\n        const response = yield fetch(`https://router.hereapi.com/v8/routes?transportMode=car&origin=${origin.lat},${origin.lng}&destination=${destination.lat},${destination.lng}&return=polyline,summary&apikey=${_this6.API_KEY}`);\n        if (!response.ok) {\n          throw new Error('Error al calcular la ruta');\n        }\n        const data = yield response.json();\n        if (data.routes && data.routes.length > 0) {\n          return data.routes[0];\n        }\n        throw new Error('No se pudo calcular la ruta');\n      })();\n    }\n    calculateOptimizedRoute(startPoint, waypoints) {\n      var _this7 = this;\n      return _asyncToGenerator(function* () {\n        yield _this7.ensureInitialized();\n        if (waypoints.length === 0) return null;\n        // Validar coordenadas\n        if (!_this7.validateCoordinates(startPoint)) {\n          throw new Error('Coordenadas del punto de inicio inválidas');\n        }\n        const validWaypoints = waypoints.filter(wp => _this7.validateCoordinates(wp));\n        if (validWaypoints.length === 0) {\n          throw new Error('No hay waypoints válidos');\n        }\n        try {\n          // Calcular ruta simple visitando todos los puntos y regresando\n          const allRouteSegments = [];\n          let currentPoint = startPoint;\n          // Ir a cada waypoint\n          for (const waypoint of validWaypoints) {\n            const routeSegment = yield _this7.calculateRoute(currentPoint, waypoint);\n            allRouteSegments.push(routeSegment);\n            currentPoint = waypoint;\n          }\n          // Regresar al punto de inicio\n          const returnSegment = yield _this7.calculateRoute(currentPoint, startPoint);\n          allRouteSegments.push(returnSegment);\n          // Combinar todos los segmentos\n          const combinedRoute = _this7.combineRouteSegments(allRouteSegments);\n          console.log('Successfully calculated optimized route with', allRouteSegments.length, 'segments');\n          return combinedRoute;\n        } catch (error) {\n          console.error('Error in calculateOptimizedRoute:', error);\n          throw error;\n        }\n      })();\n    }\n    combineRouteSegments(segments) {\n      if (segments.length === 0) return null;\n      const combinedSections = segments.map(segment => segment.sections[0]);\n      const totalSummary = segments.reduce((acc, segment) => {\n        const section = segment.sections[0];\n        acc.length += section.summary.length;\n        acc.duration += section.summary.duration;\n        return acc;\n      }, {\n        length: 0,\n        duration: 0\n      });\n      return {\n        sections: combinedSections,\n        summary: totalSummary\n      };\n    }\n    validateCoordinates(coord) {\n      return coord.lat >= -90 && coord.lat <= 90 && coord.lng >= -180 && coord.lng <= 180 && !isNaN(coord.lat) && !isNaN(coord.lng);\n    }\n    decodePolyline(polyline) {\n      if (!polyline || typeof polyline !== 'string' || polyline.length === 0) {\n        return [];\n      }\n      const coordinates = [];\n      let index = 0;\n      let lat = 0;\n      let lng = 0;\n      while (index < polyline.length) {\n        let b;\n        let shift = 0;\n        let result = 0;\n        do {\n          b = polyline.charCodeAt(index++) - 63;\n          result |= (b & 0x1f) << shift;\n          shift += 5;\n        } while (b >= 0x20);\n        const deltaLat = (result & 1) !== 0 ? ~(result >> 1) : result >> 1;\n        lat += deltaLat;\n        shift = 0;\n        result = 0;\n        do {\n          b = polyline.charCodeAt(index++) - 63;\n          result |= (b & 0x1f) << shift;\n          shift += 5;\n        } while (b >= 0x20);\n        const deltaLng = (result & 1) !== 0 ? ~(result >> 1) : result >> 1;\n        lng += deltaLng;\n        const decodedLat = lat / 1e5;\n        const decodedLng = lng / 1e5;\n        if (this.validateCoordinates({\n          lat: decodedLat,\n          lng: decodedLng\n        })) {\n          coordinates.push({\n            lat: decodedLat,\n            lng: decodedLng\n          });\n        }\n      }\n      return coordinates;\n    }\n    static {\n      this.ɵfac = function HereMapsService_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || HereMapsService)();\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: HereMapsService,\n        factory: HereMapsService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return HereMapsService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}